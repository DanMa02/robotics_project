- [FIRST EXPERIENCE](#first-experience)
  - [THE CHALLENGE](#the-challenge)
  - [LITTLE STEPS](#little-steps)
  - [EXECUTION](#execution)
    - [MOVEMENT](#movement)

# FIRST EXPERIENCE 
## THE CHALLENGE
- Build our custom world
  - For the moment only one megablock in a table and the ur5 fixed on the table
- Create a custom script that recognize the object and estimate the position
- Build the motion control script in order to use the values generated by the CV 
- Try to position the UR5 and pick up the object
  
## LITTLE STEPS
- We can try to create simple world (e.g. one cube) and then increase the complexity
- Try to locate at first the obj, than publish the data in the console. In a second moment we can try to send these datas to the UR5
- Try at first to move the UR5 than use the processed data to move the UR5
  - Try to open and close the gripper
  - Try to move it over the block
  - ...

## EXECUTION
Files can be find in the *script* folder, this is a little guide to explain how it works
### MOVEMENT
For the movement of the ur5, the topic */command* is subscribed by the **ros_impedance_controller**. Normally the file *params.py* has the field `control_type: position` but in order to use the controller we have to change this field into `control_type: torque`. So we know now that if we wanto to publish in the */command* topic we have to use the flag `torque` in order to use the **ros_impedance_controller**, instead if we want to don't change anything we have to publish in the */ur5/joint_group_pos_controller/command* and we will not use the **ros_impedance_controller**
  - If using `position` mode topic will be */ur5/joint_group_pos_controller/command*, we have to use the **Float64MultiArrays** msg that it's under the *std_msgs.msg*
  - If using `torque` mode topic will be */command*, we have to use the **JointState** msg that it's under the *sensor_msgs.msg*
